# -*- coding: utf-8 -*-
"""4_Despliegue_Modelamiento_analisis_cultivo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UMMabmVWflhW5YiAx_Qo30ZqwEmkyino

# Pipes - Despliegue

- Cargamos el modelo
- Cargamos los datos futuros
- Aplicar tubería
"""

#Cargamos librerías principales
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import pickle
filename = 'modeloCV.pkl'
pipeline = modelTree,variables,labelencoder,min_max_scaler = pickle.load(open(filename, 'rb'))
pipeline

#Recorda documentar esto para poder ejecutar streamlit
#data = pd.read_csv("datos_futuros.csv")
#data.head()

# --- LÓGICA DE PREDICCIÓN CON BOTÓN ---

if st.button('Predecir Estado Físico del Cultivo'):
    
    # 3. Crear DataFrame con los datos capturados (¡CORRECCIÓN APLICADA AQUÍ!)
    datos = [[areaSembrada, areaCosechada, produccion, rendimiento, cultivo, cicloCultivo, grupoCultivo, subGrupo, nombreCientifico]]
    
    # MODIFICACIÓN: Se añaden comillas simples a las columnas numéricas donde el scaler las espera
    input_cols_corrected = [
        "'Area Sembrada(ha)'", 
        "'AREA COSECHADA(ha)'", 
        'PRODUCCION(t)', 
        'RENDIMIENTO(t/ha)', 
        'CULTIVO', 
        'CICLO CULTIVO', 
        'GRUPO CULTIVO',
        'SUBGRUPO',
        'NOMBRE CIENTIFICO CULTIVO'
    ]
    data_input = pd.DataFrame(datos, columns=input_cols_corrected)

    # 4. Pre-procesamiento (OHE y Reindex)
    try:
        # A. Definir columnas (¡CORRECCIÓN APLICADA AQUÍ!)
        # MODIFICACIÓN: num_cols debe tener las comillas
        num_cols = [
            "'Area Sembrada(ha)'", 
            "'AREA COSECHADA(ha)'", 
            'PRODUCCION(t)', 
            'RENDIMIENTO(t/ha)'
        ]
        cat_cols = ['CULTIVO', 'CICLO CULTIVO', 'GRUPO CULTIVO', 'SUBGRUPO', 'NOMBRE CIENTIFICO CULTIVO']
        
        data_num = data_input[num_cols] # Ahora selecciona las columnas con comillas
        data_cat = data_input[cat_cols]

        # B. Aplicar el MinMaxScaler guardado a las columnas numéricas
        # ¡Esta línea ya no dará error de nombres!
        data_num_scaled = min_max_scaler.transform(data_num) 
        data_num_scaled = pd.DataFrame(data_num_scaled, columns=num_cols, index=data_input.index)

        # C. Aplicación explícita de Dummies (OHE) y el resto de la lógica...
        data_cat_ohe = pd.get_dummies(data_cat, columns=cat_cols, drop_first=False) 
        
        # D. Combinación y Alineación
        data_preparada = pd.concat([data_num_scaled, data_cat_ohe], axis=1)
        X_predict = data_preparada.reindex(columns=variables, fill_value=0)
        
        # ... (Resto de la lógica de predicción y display)
        pred_encoded = model.predict(X_predict)
        pred_decoded = labelencoder.inverse_transform(pred_encoded)[0]

        st.success('✅ Predicción Exitosa')
        st.metric(
            label="Estado Físico Predicho", 
            value=f"El cultivo se encuentra en estado: **{pred_decoded}**"
        )
        
    except Exception as e:
        # El error NameError: name 'X_predict' is not defined se solucionará
        # porque X_predict se definirá si el ValueError se resuelve.
        st.error(f"Error al realizar la predicción: {e}")
        # Muestra el DataFrame antes de la predicción si falla.
        # st.dataframe(X_predict)


#Se realiza la preparación debe ser igual al aprendizaje
#data_preparada=data.copy()
#data_preparada = pd.get_dummies(data, columns=["'CICLO DE CULTIVO'"], drop_first=True, dtype=int)
#data_preparada = pd.get_dummies(data, columns=['CULTIVO', "'GRUPO CULTIVO'", 'SUBGRUPO', "'NOMBRE CIENTIFICO CULTIVO'"], drop_first=False, dtype=int)

#data_preparada.head()

#Se adicionan las columnas faltantes
#data_preparada=data_preparada.reindex(columns=variables,fill_value=0)
#data_preparada.head()

"""# **Predicciones**"""

#Hacemos la predicción con el Tree
#Y_fut = modelTree.predict(data_preparada)
#print(Y_fut)

#print(labelencoder.inverse_transform(Y_fut))

#data['Tree']=labelencoder.inverse_transform(Y_fut)
#data.head()

#Hacemos la predicción con Ranfom Forest
#Y_fut = model_rf.predict(data_preparada)
#data['RF']=labelencoder.inverse_transform(Y_fut)
#data.head()
