# -*- coding: utf-8 -*-
"""4_Despliegue_Modelamiento_analisis_cultivo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UMMabmVWflhW5YiAx_Qo30ZqwEmkyino

# Pipes - Despliegue

- Cargamos el modelo
- Cargamos los datos futuros
- Aplicar tuber√≠a
"""

#Cargamos librer√≠as principales
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import pickle
filename = 'modeloCV.pkl'
pipeline = modelTree,variables,labelencoder,min_max_scaler = pickle.load(open(filename, 'rb'))
pipeline

#Recorda documentar esto para poder ejecutar streamlit
#data = pd.read_csv("datos_futuros.csv")
#data.head()

import streamlit as st
import pandas as pd
import numpy as np
import pickle

# --- CONFIGURACI√ìN Y CARGA DE RECURSOS ---

PICKLE_FILE = 'modeloCV.pkl'

@st.cache_resource
def load_pipeline():
    try:
        with open(PICKLE_FILE, 'rb') as file:
            # Cargamos los 4 elementos: modelo, lista de variables (columnas), LE, MinMaxScaler
            modelTree, variables, labelencoder, min_max_scaler = pickle.load(file)

        return modelTree, variables, labelencoder, min_max_scaler
    except FileNotFoundError:
        st.error(f"Error: No se encontr√≥ el archivo del pipeline en '{PICKLE_FILE}'.")
        st.stop()
    except Exception as e:
        st.error(f"Error al cargar el pipeline (pickle): {e}")
        st.stop()

# Cargamos los recursos (Modelo, lista de columnas de X_train, LabelEncoder, MinMaxScaler)
modelTree, variables, labelencoder, min_max_scaler = load_pipeline()

# --- DEFINICI√ìN DE INTERFAZ GR√ÅFICA ---

st.title('Predicci√≥n de Estado F√≠sico del Cultivo')
st.markdown("---")

# 1. Inputs Num√©ricos
areaSembrada = st.slider('Area Sembrada(ha)', min_value=0, max_value=1000, value=20, step=1)
areaCosechada = st.slider('AREA COSECHADA(ha)', min_value=0, max_value=350, value=20, step=1)
produccion = st.slider('PRODUCCION(t)', min_value=0, max_value=3500, value=20, step=1)
rendimiento = st.slider('RENDIMIENTO(t/ha)', min_value=0.0, max_value=10.0, value=5.0, step=0.1)

# 2. Inputs Categ√≥ricos
cultivo = st.selectbox('CULTIVO', ["Aguacate demAs variedades", "MaIz Tradicional", "Frijol", "'LimOn Pajarito"])
cicloCultivo = st.selectbox('CICLO CULTIVO', ["Permanente", "Transitorio"])
grupoCultivo = st.selectbox('GRUPO CULTIVO', ["Frutales", "Cereales","Leguminosas"])
subGrupo = st.selectbox('SUBGRUPO', ["Demas frutales", "Cereales","Leguminosas", "CItricos"])
nombreCientifico = st.selectbox('NOMBRE CIENTIFICO CULTIVO', ["Persea americana", "Zea mays","Phaseolus sp", "Citrus limon L."])

# --- L√ìGICA DE PREDICCI√ìN CON BOT√ìN ---

if st.button('Predecir Estado F√≠sico del Cultivo'):

    # 3. Crear DataFrame con los datos capturados
    datos = [[areaSembrada, areaCosechada, produccion, rendimiento, cultivo, cicloCultivo, grupoCultivo, subGrupo, nombreCientifico]]
    data_input = pd.DataFrame(datos, columns=['Area Sembrada(ha)', 'AREA COSECHADA(ha)', 'PRODUCCION(t)', 'RENDIMIENTO(t/ha)', 'CULTIVO', 'CICLO CULTIVO', 'GRUPO CULTIVO','SUBGRUPO','NOMBRE CIENTIFICO CULTIVO'])

    # 4. Pre-procesamiento (OHE y Reindex)
    try:
        # A. Definir columnas
        num_cols = ['Area Sembrada(ha)', 'AREA COSECHADA(ha)', 'PRODUCCION(t)', 'RENDIMIENTO(t/ha)']
        cat_cols = ['CULTIVO', 'CICLO CULTIVO', 'GRUPO CULTIVO', 'SUBGRUPO', 'NOMBRE CIENTIFICO CULTIVO']

        data_num = data_input[num_cols]
        data_cat = data_input[cat_cols]

        # B. Aplicar el MinMaxScaler guardado a las columnas num√©ricas
        data_num_scaled = min_max_scaler.transform(data_num)
        data_num_scaled = pd.DataFrame(data_num_scaled, columns=num_cols, index=data_input.index)

        # C. üì¢ APLICACI√ìN EXPL√çCITA DE DUMMIES (ONE-HOT ENCODING)
        # Se aplica OHE a las variables categ√≥ricas sin eliminar la primera columna (drop_first=False)
        data_cat_ohe = pd.get_dummies(data_cat, columns=cat_cols, drop_first=False)

        # D. COMBINACI√ìN Y ALINEACI√ìN DE COLUMNAS (PASO CR√çTICO RESUELTO)

        # 1. Combinar num√©ricas escaladas y categ√≥ricas OHE
        data_preparada = pd.concat([data_num_scaled, data_cat_ohe], axis=1)

        # 2. üì¢ ALINEACI√ìN FINAL con .reindex()
        # Se utiliza la lista 'variables' (columnas de X_train) para ordenar y a√±adir las columnas faltantes (fill_value=0)
        X_predict = data_preparada.reindex(columns=variables, fill_value=0)

        # 5. Predicci√≥n
        pred_encoded = modelTree.predict(X_predict)

        # 6. Inversi√≥n del LabelEncoder
        pred_decoded = labelencoder.inverse_transform(pred_encoded)[0]

        # 7. Mostrar Resultado
        st.success('‚úÖ Predicci√≥n Exitosa')
        st.metric(
            label="Estado F√≠sico Predicho",
            value=f"El cultivo se encuentra en estado: **{pred_decoded}**"
        )

    except Exception as e:
        st.error(f"Error al realizar la predicci√≥n. Aseg√∫rate de que el pre-procesamiento coincida con el modelo: {e}")
        st.dataframe(X_predict)

#Se realiza la preparaci√≥n debe ser igual al aprendizaje
#data_preparada=data.copy()
#data_preparada = pd.get_dummies(data, columns=["'CICLO DE CULTIVO'"], drop_first=True, dtype=int)
#data_preparada = pd.get_dummies(data, columns=['CULTIVO', "'GRUPO CULTIVO'", 'SUBGRUPO', "'NOMBRE CIENTIFICO CULTIVO'"], drop_first=False, dtype=int)

#data_preparada.head()

#Se adicionan las columnas faltantes
#data_preparada=data_preparada.reindex(columns=variables,fill_value=0)
#data_preparada.head()

"""# **Predicciones**"""

#Hacemos la predicci√≥n con el Tree
#Y_fut = modelTree.predict(data_preparada)
#print(Y_fut)

#print(labelencoder.inverse_transform(Y_fut))

#data['Tree']=labelencoder.inverse_transform(Y_fut)
#data.head()

#Hacemos la predicci√≥n con Ranfom Forest
#Y_fut = model_rf.predict(data_preparada)
#data['RF']=labelencoder.inverse_transform(Y_fut)
#data.head()